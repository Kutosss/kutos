uniform sampler2D SCREEN_TEXTURE;
uniform highp float SCANLINE_INTENSITY; // 0.0 - 1.0, intensity of scanline effect
uniform highp float DISTORTION; // 0.0 - 0.1, amount of CRT-like distortion
uniform highp float TIME_COEFFICIENT; // Speed of scanline movement

// Noise function
highp float rand(highp vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

// Neon glow effect
highp vec3 neonGlow(highp vec3 color, highp float intensity) {
    highp float brightness = dot(color, vec3(0.299, 0.587, 0.114));
    highp vec3 neon = vec3(0.0);

    // Cyan neon glow for bright areas
    if (brightness > 0.65) {
        neon += vec3(0.0, 1.0, 1.0) * (brightness - 0.65) * 2.5;
    }

    // Magenta neon glow for mid-bright areas
    if (brightness > 0.45 && brightness < 0.75) {
        neon += vec3(1.0, 0.0, 0.8) * (brightness - 0.45) * 1.8;
    }

    return color + neon * intensity;
}

// Function to detect if a pixel is likely part of a crosshair/UI element
bool isUIElement(highp vec4 color) {
    // Check for very bright white/light colors which are likely UI elements
    highp float brightness = dot(color.rgb, vec3(0.299, 0.587, 0.114));
    
    // If it's very bright and has high contrast with surroundings, likely UI
    if (brightness > 0.9 && color.a > 0.9) {
        return true;
    }
    
    // Check for specific UI colors (like reticle colors)
    // Assuming reticle might be bright red, green, blue, or white
    if ((color.r > 0.9 && color.g < 0.3 && color.b < 0.3) || // Red
        (color.r < 0.3 && color.g > 0.9 && color.b < 0.3) || // Green
        (color.r < 0.3 && color.g < 0.3 && color.b > 0.9) || // Blue
        (color.r > 0.9 && color.g > 0.9 && color.b > 0.9)) { // White
        return true;
    }
    
    return false;
}

void fragment() {
    // Get original screen color
    highp vec4 originalColor = texture2D(SCREEN_TEXTURE, UV);
    
    // Check if this pixel might be part of a UI element like crosshair
    if (isUIElement(originalColor)) {
        // Preserve UI elements with minimal effect
        // Add just a subtle neon glow to UI elements to make them more visible
        COLOR = vec4(neonGlow(originalColor.rgb, 0.3), originalColor.a);
        return;
    }
    
    // Very minimal distortion
    highp vec2 uv = UV;
    highp vec2 center = vec2(0.5, 0.5);
    highp vec2 dist = uv - center;
    highp float barrelFactor = dot(dist, dist) * (DISTORTION * 0.1);
    uv = uv + dist * barrelFactor;
    
    // If UV coordinates are outside the texture, use original color
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
        COLOR = originalColor;
        return;
    }
    
    // Subtle RGB shift with more blue/cyan
    highp float aberration = DISTORTION * 0.028;
    highp vec4 r = texture2D(SCREEN_TEXTURE, uv + vec2(aberration, 0.0));
    highp vec4 g = texture2D(SCREEN_TEXTURE, uv);
    highp vec4 b = texture2D(SCREEN_TEXTURE, uv - vec2(aberration, -aberration * 0.5)); // Shift blue diagonally
    
    // Combine the color channels with balanced brightness - slightly brighter
    highp vec4 color = vec4(r.r * 1.06, g.g * 1.18, b.b * 1.28, g.a);
    
    // Create horizontal scanlines instead of vertical
    highp float scanY = uv.y * 1200.0; // Dense horizontal lines
    highp float scanline = 1.0;
    
    // Hard-edged horizontal scanlines with moderate contrast
    if (mod(floor(scanY), 2.0) == 0.0) {
        scanline = 0.83; // Moderate darkness for scanlines
    }
    
    // Apply scanlines
    color.rgb *= scanline;
    
    // Medium vignette effect
    highp float vignette = 1.0 - dot(dist, dist) * 1.35;
    color.rgb *= vignette;
    
    // Apply cyberpunk-inspired color grading - balanced but brighter
    highp vec3 tint = vec3(0.78, 1.08, 1.28); // Cyan-blue dominant
    color.rgb = mix(color.rgb, color.rgb * tint, 0.75);
    
    // Moderate brightness adjustment - slightly reduced
    color.rgb *= 1.14;
    
    // Add neon glow effect - balanced
    color.rgb = neonGlow(color.rgb, 0.82);
    
    // Add minimal digital noise - significantly reduced
    highp float noise = rand(uv + vec2(TIME * 0.001, TIME * 0.001)) * 0.005; // Reduced noise amount
    color.rgb += vec3(noise) * vec3(0.6, 0.9, 1.1); // Colorful noise
    
    // Add subtle flicker - less dark
    highp float flicker = 0.98 + 0.03 * sin(TIME * 2.5);
    color.rgb *= flicker;
    
    // Boost contrast for more vibrant look but maintain balanced brightness - slightly darker
    color.rgb = (color.rgb - 0.42) * 1.16 + 0.48;
    
    // Ensure alpha is preserved
    COLOR = vec4(color.rgb, color.a);
}
